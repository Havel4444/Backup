#!/usr/bin/env python3

## 1. Clase y objeto: Definiendo el nombre, edad y grado.
def p1():
    class Persona:
        # Constructor
        def __init__(self, nombre, edad, grado):
            self.nombre = nombre
            self.edad = edad
            self.grado = grado
    
        # Metodo.
        def saludo(self):
            return f"Hola, soy {self.nombre} y tengo {self.edad} de grado {self.grado}."
    
    # Objeto = Instancia
    diego = Persona("Diego", 24, "A")
    roberto = Persona("roberto", 14, "F")
    
    print(diego.saludo())
    print(roberto.saludo())

## 2. Clase y objeto: Estado de una cuenta + agregar y retirar dinero.
def p2():
    class Banco: 
        def __init__(self, nombre, dni, cuenta, dinero):
            self.cuenta = cuenta
            self.nombre = nombre
            self.dni = dni
            self.dinero = dinero

        def plata(self):
            return f"[#][{self.nombre}] Cuenta: ${self.dinero}."

        def deposito(self, money):
            self.dinero += money
            return f"[+][{self.nombre}] Depositado: ${money}; Cuenta actual: ${self.dinero}."

        def retirar(self, yenom):
            if yenom > self.dinero:
                return f"[!][{self.nombre}] Denegado. El valor ${yenom} excede tu cuenta: ${self.dinero}."
            else:
                self.dinero -= yenom 
                return f"[+][{self.nombre}] Retirado: ${yenom}; Restante: ${self.dinero}."

    marcelo = Banco("Marcelo", 42440777, 12345678910, 1000)
    
    print(marcelo.plata())
    print(marcelo.deposito(2896))
    print(marcelo.retirar(4000))

## 3. b*h/2: Conseguir el area de una figura; Usar @property + objeto.
def p3():
    class Area:
        def __init__(self, base, altura):
            self.base = base 
            self.altura = altura 

        def area_triangulo(self):
            calculo = self.base * self.altura // 2
            return f"\n[+] Area del triangulo: {calculo}"            

    triangulo = Area(8, 4)
    print(triangulo.area_triangulo)

## 4. __str__: Usar @property en un objeto.
def p4():
    class Area:
        def __init__(self, base, altura):
            self.base = base 
            self.altura = altura 

        @property # Forzar a ejecutar el metodo sin parentesis.
        def area_triangulo(self):
            calculo = self.base * self.altura // 2
            return f"\n[+] Area del triangulo: {calculo}"            

        def __str__(self): # C. para mostrar los valores del objeto.
            return f"\n[#] Base: {self.base}; Altura: {self.altura}"

    triangulo = Area(8, 4)
    print(triangulo)

## 5. __eq__: 
def p5():
    class Area:
        def __init__(self, base, altura):
            self.base = base 
            self.altura = altura 
        
        def area_triangulo(self):
            calculo = self.base * self.altura // 2
            return f"\n[+] Area del triangulo: {calculo}"            

        def __eq__(self, otro):
            return self.base == otro.base and self.altura == otro.altura

    triangulo_1 = Area(4, 4)
    triangulo_2 = Area(8, 4)
    print(triangulo_1.area_triangulo())
    print(triangulo_2.area_triangulo())
    print(f"\nÂ¿Son iguales?: {triangulo_1 == triangulo_2}")

## 6. Staticmethod:
def p6():
    class Auto:
        valor = 15654

        def __init__(self, marca, modelo, costo):
            self.marca = marca
            self.modelo = modelo
            self.costo = costo

        @staticmethod # Decorador.
        def ahorrado(disponible):
            # Devuelve un valor booleano.
            #return f"{disponible > Auto.valor}: Puedes comprarlo."
            return "Puedes comprarlo." if disponible > Auto.valor else "No puedes comprarlo." 

    cuenta_bancaria = Auto("Renault", "Alaskan", 15654)

    print(Auto.ahorrado(16000))




